# Benchmarks

## Running a benchmark session

### Set up some KUDO Cassandra instance information

```bash
kudo_cassandra_operator_name="cassandra"
kudo_cassandra_operator_version="0.1.2"
kudo_cassandra_instance_name="cassandra"
kudo_cassandra_instance_namespace="mwt"
kudo_cassandra_statefulset_name="node"

svc_endpoint="${kudo_cassandra_instance_name}-svc.${kudo_cassandra_instance_namespace}.svc.cluster.local"
```

### Create namespace

```bash
kubectl create namespace "${kudo_cassandra_instance_namespace}"
```

### Setup required RBAC

#### Create Cluster Role
```bash
kubectl apply -f - <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: node-resolver-role
rules:
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["get", "watch", "list"]
EOF
```

#### Create Service Account
```bash
kubectl apply -f - <<EOF
apiVersion: v1
kind: ServiceAccount
metadata:
  name: node-resolver
  namespace: ${kudo_cassandra_instance_namespace}
EOF
```

#### Create ClusterRoleBinding
```bash
kubectl apply -f - <<EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: node-resolver-binding
subjects:
- kind: ServiceAccount
  name: node-resolver
  namespace: ${kudo_cassandra_instance_namespace}
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: node-resolver-role
EOF
```

### Install KUDO Cassandra with some parameters

Tweak the parameters as desired.

```bash
kubectl kudo install ./operator \
        --instance="${kudo_cassandra_instance_name}" \
        --namespace="${kudo_cassandra_instance_namespace}" \
        --parameter-file benchmarks/mwt/params-local-2dc.yaml
```


### Wait for deploy plan to be `COMPLETE`

```bash
kubectl kudo plan status \
        --instance="${kudo_cassandra_instance_name}" \
        --namespace="${kudo_cassandra_instance_namespace}"
```

### Make sure `nodetool status` looks good

```bash
pod="0"
container="cassandra"
kubectl exec "pod/${kudo_cassandra_instance_name}-${kudo_cassandra_statefulset_name}-${pod}" \
        -n "${kudo_cassandra_instance_namespace}" \
        -c "${container}" \
        -- \
        bash -c "\
          nodetool status
        "
```

### Run `kassandra-stress`

This will create a Kubernetes deployment resource. Tweak the parameters as
desired.

```bash
workload_name="cassandra-workload"
```

```bash
./benchmarks/kassandra-stress \
  --kubernetes-namespace "${kudo_cassandra_instance_namespace}" \
  --workload-name "${workload_name}" \
  --hosts "${svc_endpoint}" \
  --number-of-clients 20 \
  --keyspace-name "cassandra_stress" \
  --one-keyspace-per-client false \
  --duration "1h"
```

Workload A - 2 Datacenters
```bash
kassandra-stress \
  --kubernetes-namespace "${kudo_cassandra_instance_namespace}" \
  --workload-name "${workload_name}" \
  --hosts "${svc_endpoint}" \
  --number-of-clients 5 \
  --keyspace-name "cassandra_stress" \
  --one-keyspace-per-client false \
  --duration "15m" \
  --threads_per_client=250 \
  --keyspace-replication-string="strategy=NetworkTopologyStrategy, ring1=1, ring2=1"
  --consistency-level=LOCAL_ONE
```

Workload B - 2 Datacenters
```bash
kassandra-stress \
  --kubernetes-namespace "${kudo_cassandra_instance_namespace}" \
  --workload-name "${workload_name}" \
  --hosts "${svc_endpoint}" \
  --number-of-clients 5 \
  --keyspace-name "cassandra_stress" \
  --one-keyspace-per-client false \
  --duration "15m" \
  --threads_per_client=250 \
  --keyspace-replication-string="strategy=NetworkTopologyStrategy, ring1=3, ring2=3"
  --consistency-level=LOCAL_QUORUM
```

### Generate workload by applying the deployment generated by `kassandra-stress`

```bash
kubectl apply -f benchmarks/kassandra_stress_replica_set.yaml
```

### Check workload deployment

```bash
kubectl get deployment -n "${kudo_cassandra_instance_namespace}"
```

### Check workload pods

```bash
kubectl get pod -n "${kudo_cassandra_instance_namespace}" | grep "${workload_name}"
```

Save the pod names into a variable
```bash
pods=`kubectl get pod -n "${kudo_cassandra_instance_namespace}" | grep "${workload_name}" | awk '{print $1}'`
```

Wait until all pods have finished the stress generation
```bash
for pod in ${pods}; do
  echo $pod `kubectl logs --tail 20 "$pod" -n "${kudo_cassandra_instance_namespace}" | grep 'END\|RuntimeException' || echo "Not finished"`
done
```

### Copy artifacts
```bash
for pod in ${pods}; do
  echo $pod 
  kubectl logs "$pod" -n "${kudo_cassandra_instance_namespace}" > stdout_$pod.txt
  kubectl cp "${kudo_cassandra_instance_namespace}"/$pod:/tmp/cassandra-workload.html workload_$pod.html
done
```

### Delete workload

```bash
kubectl delete deployment "${workload_name}" -n "${kudo_cassandra_instance_namespace}"
```

### Uninstall operator

```bash
./scripts/uninstall_operator.sh \
  --operator "${kudo_cassandra_operator_name}" \
  --version "${kudo_cassandra_operator_version}" \
  --instance "${kudo_cassandra_instance_name}" \
```
